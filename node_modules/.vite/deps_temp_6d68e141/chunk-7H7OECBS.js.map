{
  "version": 3,
  "sources": ["../../@dfinity/candid/src/idl.ts", "../../@dfinity/candid/src/utils/buffer.ts", "../../@dfinity/candid/src/utils/hash.ts", "../../@dfinity/candid/src/utils/leb128.ts", "../../@dfinity/candid/src/utils/bigint-math.ts", "../../@dfinity/candid/src/candid-core.ts", "../../@dfinity/candid/src/candid-ui.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Principal as PrincipalId } from '@dfinity/principal';\nimport { JsonValue } from './types';\nimport { concat, PipeArrayBuffer as Pipe } from './utils/buffer';\nimport { idlLabelToId } from './utils/hash';\nimport {\n  lebDecode,\n  lebEncode,\n  readIntLE,\n  readUIntLE,\n  safeRead,\n  safeReadUint8,\n  slebDecode,\n  slebEncode,\n  writeIntLE,\n  writeUIntLE,\n} from './utils/leb128';\nimport { iexp2 } from './utils/bigint-math';\n\n/**\n * This module provides a combinator library to create serializers/deserializers\n * between JavaScript values and IDL used by canisters on the Internet Computer,\n * as documented at https://github.com/dfinity/candid/blob/119703ba342d2fef6ab4972d2541b9fe36ae8e36/spec/Candid.md\n */\n\nconst enum IDLTypeIds {\n  Null = -1,\n  Bool = -2,\n  Nat = -3,\n  Int = -4,\n  Float32 = -13,\n  Float64 = -14,\n  Text = -15,\n  Reserved = -16,\n  Empty = -17,\n  Opt = -18,\n  Vector = -19,\n  Record = -20,\n  Variant = -21,\n  Func = -22,\n  Service = -23,\n  Principal = -24,\n}\n\nconst magicNumber = 'DIDL';\nconst toReadableString_max = 400; // will not display arguments after 400chars. Makes sure 2mb blobs don't get inside the error\n\nfunction zipWith<TX, TY, TR>(xs: TX[], ys: TY[], f: (a: TX, b: TY) => TR): TR[] {\n  return xs.map((x, i) => f(x, ys[i]));\n}\n\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n  // List of types. Needs to be an array as the index needs to be stable.\n  private _typs: ArrayBuffer[] = [];\n  private _idx = new Map<string, number>();\n\n  public has(obj: ConstructType) {\n    return this._idx.has(obj.name);\n  }\n\n  public add<T>(type: ConstructType<T>, buf: ArrayBuffer) {\n    const idx = this._typs.length;\n    this._idx.set(type.name, idx);\n    this._typs.push(buf);\n  }\n\n  public merge<T>(obj: ConstructType<T>, knot: string) {\n    const idx = this._idx.get(obj.name);\n    const knotIdx = this._idx.get(knot);\n    if (idx === undefined) {\n      throw new Error('Missing type index for ' + obj);\n    }\n    if (knotIdx === undefined) {\n      throw new Error('Missing type index for ' + knot);\n    }\n    this._typs[idx] = this._typs[knotIdx];\n\n    // Delete the type.\n    this._typs.splice(knotIdx, 1);\n    this._idx.delete(knot);\n  }\n\n  public encode() {\n    const len = lebEncode(this._typs.length);\n    const buf = concat(...this._typs);\n    return concat(len, buf);\n  }\n\n  public indexOf(typeName: string) {\n    if (!this._idx.has(typeName)) {\n      throw new Error('Missing type index for ' + typeName);\n    }\n    return slebEncode(this._idx.get(typeName) || 0);\n  }\n}\n\nexport abstract class Visitor<D, R> {\n  public visitType<T>(t: Type<T>, data: D): R {\n    throw new Error('Not implemented');\n  }\n  public visitPrimitive<T>(t: PrimitiveType<T>, data: D): R {\n    return this.visitType(t, data);\n  }\n  public visitEmpty(t: EmptyClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitBool(t: BoolClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitNull(t: NullClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitReserved(t: ReservedClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitText(t: TextClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitNumber<T>(t: PrimitiveType<T>, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitInt(t: IntClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitNat(t: NatClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitFloat(t: FloatClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitFixedInt(t: FixedIntClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitFixedNat(t: FixedNatClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitPrincipal(t: PrincipalClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n\n  public visitConstruct<T>(t: ConstructType<T>, data: D): R {\n    return this.visitType(t, data);\n  }\n  public visitVec<T>(t: VecClass<T>, ty: Type<T>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitOpt<T>(t: OptClass<T>, ty: Type<T>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitRecord(t: RecordClass, fields: Array<[string, Type]>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitTuple<T extends any[]>(t: TupleClass<T>, components: Type[], data: D): R {\n    const fields: Array<[string, Type]> = components.map((ty, i) => [`_${i}_`, ty]);\n    return this.visitRecord(t, fields, data);\n  }\n  public visitVariant(t: VariantClass, fields: Array<[string, Type]>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitRec<T>(t: RecClass<T>, ty: ConstructType<T>, data: D): R {\n    return this.visitConstruct(ty, data);\n  }\n  public visitFunc(t: FuncClass, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitService(t: ServiceClass, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n}\n\n/**\n * Represents an IDL type.\n */\nexport abstract class Type<T = any> {\n  public abstract readonly name: string;\n  public abstract accept<D, R>(v: Visitor<D, R>, d: D): R;\n\n  /* Display type name */\n  public display(): string {\n    return this.name;\n  }\n\n  public valueToString(x: T): string {\n    return toReadableString(x);\n  }\n\n  /* Implement `T` in the IDL spec, only needed for non-primitive types */\n  public buildTypeTable(typeTable: TypeTable): void {\n    if (!typeTable.has(this)) {\n      this._buildTypeTableImpl(typeTable);\n    }\n  }\n\n  /**\n   * Assert that JavaScript's `x` is the proper type represented by this\n   * Type.\n   */\n  public abstract covariant(x: any): x is T;\n\n  /**\n   * Encode the value. This needs to be public because it is used by\n   * encodeValue() from different types.\n   * @internal\n   */\n  public abstract encodeValue(x: T): ArrayBuffer;\n\n  /**\n   * Implement `I` in the IDL spec.\n   * Encode this type for the type table.\n   */\n  public abstract encodeType(typeTable: TypeTable): ArrayBuffer;\n\n  public abstract checkType(t: Type): Type;\n  public abstract decodeValue(x: Pipe, t: Type): T;\n\n  protected abstract _buildTypeTableImpl(typeTable: TypeTable): void;\n}\n\nexport abstract class PrimitiveType<T = any> extends Type<T> {\n  public checkType(t: Type): Type {\n    if (this.name !== t.name) {\n      throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    return t;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public _buildTypeTableImpl(typeTable: TypeTable): void {\n    // No type table encoding for Primitive types.\n    return;\n  }\n}\n\nexport abstract class ConstructType<T = any> extends Type<T> {\n  public checkType(t: Type): ConstructType<T> {\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      }\n      return ty;\n    }\n    throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n  }\n  public encodeType(typeTable: TypeTable) {\n    return typeTable.indexOf(this.name);\n  }\n}\n\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nexport class EmptyClass extends PrimitiveType<never> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitEmpty(this, d);\n  }\n\n  public covariant(x: any): x is never {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): never {\n    throw new Error('Empty cannot appear as a function argument');\n  }\n\n  public valueToString(): never {\n    throw new Error('Empty cannot appear as a value');\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Empty);\n  }\n\n  public decodeValue(): never {\n    throw new Error('Empty cannot appear as an output');\n  }\n\n  get name() {\n    return 'empty';\n  }\n}\n\n/**\n * Represents an IDL Unknown, a placeholder type for deserialization only.\n * When decoding a value as Unknown, all fields will be retained but the names are only available in\n * hashed form.\n * A deserialized unknown will offer it's actual type by calling the `type()` function.\n * Unknown cannot be serialized and attempting to do so will throw an error.\n */\nexport class UnknownClass extends Type {\n  public checkType(t: Type): Type {\n    throw new Error('Method not implemented for unknown.');\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    throw v.visitType(this, d);\n  }\n\n  public covariant(x: any): x is any {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): never {\n    throw new Error('Unknown cannot appear as a function argument');\n  }\n\n  public valueToString(): never {\n    throw new Error('Unknown cannot appear as a value');\n  }\n\n  public encodeType(): never {\n    throw new Error('Unknown cannot be serialized');\n  }\n\n  public decodeValue(b: Pipe, t: Type): any {\n    let decodedValue = t.decodeValue(b, t);\n\n    if (Object(decodedValue) !== decodedValue) {\n      // decodedValue is primitive. Box it, otherwise we cannot add the type() function.\n      // The type() function is important for primitives because otherwise we cannot tell apart the\n      // different number types.\n      decodedValue = Object(decodedValue);\n    }\n\n    let typeFunc;\n    if (t instanceof RecClass) {\n      typeFunc = () => t.getType();\n    } else {\n      typeFunc = () => t;\n    }\n    // Do not use 'decodedValue.type = typeFunc' because this would lead to an enumerable property\n    // 'type' which means it would be serialized if the value would be candid encoded again.\n    // This in turn leads to problems if the decoded value is a variant because these values are\n    // only allowed to have a single property.\n    Object.defineProperty(decodedValue, 'type', {\n      value: typeFunc,\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n    return decodedValue;\n  }\n\n  protected _buildTypeTableImpl(): void {\n    throw new Error('Unknown cannot be serialized');\n  }\n\n  get name() {\n    return 'Unknown';\n  }\n}\n\n/**\n * Represents an IDL Bool\n */\nexport class BoolClass extends PrimitiveType<boolean> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitBool(this, d);\n  }\n\n  public covariant(x: any): x is boolean {\n    if (typeof x === 'boolean') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: boolean): ArrayBuffer {\n    return new Uint8Array([x ? 1 : 0]);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Bool);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    switch (safeReadUint8(b)) {\n      case 0:\n        return false;\n      case 1:\n        return true;\n      default:\n        throw new Error('Boolean value out of range');\n    }\n  }\n\n  get name() {\n    return 'bool';\n  }\n}\n\n/**\n * Represents an IDL Null\n */\nexport class NullClass extends PrimitiveType<null> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitNull(this, d);\n  }\n\n  public covariant(x: any): x is null {\n    if (x === null) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue() {\n    return new ArrayBuffer(0);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Null);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return null;\n  }\n\n  get name() {\n    return 'null';\n  }\n}\n\n/**\n * Represents an IDL Reserved\n */\nexport class ReservedClass extends PrimitiveType<any> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitReserved(this, d);\n  }\n\n  public covariant(x: any): x is any {\n    return true;\n  }\n\n  public encodeValue() {\n    return new ArrayBuffer(0);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Reserved);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    if (t.name !== this.name) {\n      t.decodeValue(b, t);\n    }\n    return null;\n  }\n\n  get name() {\n    return 'reserved';\n  }\n}\n\n/**\n * Represents an IDL Text\n */\nexport class TextClass extends PrimitiveType<string> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitText(this, d);\n  }\n\n  public covariant(x: any): x is string {\n    if (typeof x === 'string') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: string) {\n    const buf = new TextEncoder().encode(x);\n    const len = lebEncode(buf.byteLength);\n    return concat(len, buf);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Text);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const len = lebDecode(b);\n    const buf = safeRead(b, Number(len));\n    const decoder = new TextDecoder('utf8', { fatal: true });\n    return decoder.decode(buf);\n  }\n\n  get name() {\n    return 'text';\n  }\n\n  public valueToString(x: string) {\n    return '\"' + x + '\"';\n  }\n}\n\n/**\n * Represents an IDL Int\n */\nexport class IntClass extends PrimitiveType<bigint> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitInt(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if (typeof x === 'bigint' || Number.isInteger(x)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return slebEncode(x);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Int);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return slebDecode(b);\n  }\n\n  get name() {\n    return 'int';\n  }\n\n  public valueToString(x: bigint) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Nat\n */\nexport class NatClass extends PrimitiveType<bigint> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitNat(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if ((typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return lebEncode(x);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Nat);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return lebDecode(b);\n  }\n\n  get name() {\n    return 'nat';\n  }\n\n  public valueToString(x: bigint) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Float\n */\nexport class FloatClass extends PrimitiveType<number> {\n  constructor(private _bits: number) {\n    super();\n    if (_bits !== 32 && _bits !== 64) {\n      throw new Error('not a valid float type');\n    }\n  }\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFloat(this, d);\n  }\n\n  public covariant(x: any): x is number {\n    if (typeof x === 'number' || x instanceof Number) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: number) {\n    const buf = new ArrayBuffer(this._bits / 8);\n    const view = new DataView(buf);\n    if (this._bits === 32) {\n      view.setFloat32(0, x, true);\n    } else {\n      view.setFloat64(0, x, true);\n    }\n    return buf;\n  }\n\n  public encodeType() {\n    const opcode = this._bits === 32 ? IDLTypeIds.Float32 : IDLTypeIds.Float64;\n    return slebEncode(opcode);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const bytes = safeRead(b, this._bits / 8);\n    const view = new DataView(bytes);\n    if (this._bits === 32) {\n      return view.getFloat32(0, true);\n    } else {\n      return view.getFloat64(0, true);\n    }\n  }\n\n  get name() {\n    return 'float' + this._bits;\n  }\n\n  public valueToString(x: number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL fixed-width Int(n)\n */\nexport class FixedIntClass extends PrimitiveType<bigint | number> {\n  constructor(public readonly _bits: number) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFixedInt(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    const min = iexp2(this._bits - 1) * BigInt(-1);\n    const max = iexp2(this._bits - 1) - BigInt(1);\n    let ok = false;\n    if (typeof x === 'bigint') {\n      ok = x >= min && x <= max;\n    } else if (Number.isInteger(x)) {\n      const v = BigInt(x);\n      ok = v >= min && v <= max;\n    } else {\n      ok = false;\n    }\n\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return writeIntLE(x, this._bits / 8);\n  }\n\n  public encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-9 - offset);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const num = readIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `int${this._bits}`;\n  }\n\n  public valueToString(x: bigint | number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nexport class FixedNatClass extends PrimitiveType<bigint | number> {\n  constructor(public readonly _bits: number) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFixedNat(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    const max = iexp2(this._bits);\n    let ok = false;\n    if (typeof x === 'bigint' && x >= BigInt(0)) {\n      ok = x < max;\n    } else if (Number.isInteger(x) && x >= 0) {\n      const v = BigInt(x);\n      ok = v < max;\n    } else {\n      ok = false;\n    }\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return writeUIntLE(x, this._bits / 8);\n  }\n\n  public encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-5 - offset);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const num = readUIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `nat${this._bits}`;\n  }\n\n  public valueToString(x: bigint | number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Array\n *\n * Arrays of fixed-sized nat/int type (e.g. nat8), are encoded from and decoded to TypedArrays (e.g. Uint8Array).\n * Arrays of float or other non-primitive types are encoded/decoded as untyped array in Javascript.\n * @param {Type} t\n */\nexport class VecClass<T> extends ConstructType<T[]> {\n  // If true, this vector is really a blob and we can just use memcpy.\n  //\n  // NOTE:\n  // With support of encoding/dencoding of TypedArrays, this optimization is\n  // only used when plain array of bytes are passed as encoding input in order\n  // to be backward compatible.\n  private _blobOptimization = false;\n\n  constructor(protected _type: Type<T>) {\n    super();\n    if (_type instanceof FixedNatClass && _type._bits === 8) {\n      this._blobOptimization = true;\n    }\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitVec(this, this._type, d);\n  }\n\n  public covariant(x: any): x is T[] {\n    // Special case for ArrayBuffer\n    const bits =\n      this._type instanceof FixedNatClass\n        ? this._type._bits\n        : this._type instanceof FixedIntClass\n        ? this._type._bits\n        : 0;\n\n    if (\n      (ArrayBuffer.isView(x) && bits == (x as any).BYTES_PER_ELEMENT * 8) ||\n      (Array.isArray(x) &&\n        x.every((v, idx) => {\n          try {\n            return this._type.covariant(v);\n          } catch (e: any) {\n            throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${idx} -> ${e.message}`);\n          }\n        }))\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: T[]) {\n    const len = lebEncode(x.length);\n    if (this._blobOptimization) {\n      return concat(len, new Uint8Array(x as unknown as number[]));\n    }\n    if (ArrayBuffer.isView(x)) {\n      return concat(len, new Uint8Array(x.buffer));\n    }\n    const buf = new Pipe(new ArrayBuffer(len.byteLength + x.length), 0);\n    buf.write(len);\n    for (const d of x) {\n      const encoded = this._type.encodeValue(d);\n      buf.write(new Uint8Array(encoded));\n    }\n    return buf.buffer;\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(IDLTypeIds.Vector);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  public decodeValue(b: Pipe, t: Type): T[] {\n    const vec = this.checkType(t);\n    if (!(vec instanceof VecClass)) {\n      throw new Error('Not a vector type');\n    }\n    const len = Number(lebDecode(b));\n\n    if (this._type instanceof FixedNatClass) {\n      if (this._type._bits == 8) {\n        return new Uint8Array(b.read(len)) as unknown as T[];\n      }\n      if (this._type._bits == 16) {\n        return new Uint16Array(b.read(len * 2)) as unknown as T[];\n      }\n      if (this._type._bits == 32) {\n        return new Uint32Array(b.read(len * 4)) as unknown as T[];\n      }\n      if (this._type._bits == 64) {\n        return new BigUint64Array(b.read(len * 8)) as unknown as T[];\n      }\n    }\n\n    if (this._type instanceof FixedIntClass) {\n      if (this._type._bits == 8) {\n        return new Int8Array(b.read(len)) as unknown as T[];\n      }\n      if (this._type._bits == 16) {\n        return new Int16Array(b.read(len * 2)) as unknown as T[];\n      }\n      if (this._type._bits == 32) {\n        return new Int32Array(b.read(len * 4)) as unknown as T[];\n      }\n      if (this._type._bits == 64) {\n        return new BigInt64Array(b.read(len * 8)) as unknown as T[];\n      }\n    }\n\n    const rets: T[] = [];\n    for (let i = 0; i < len; i++) {\n      rets.push(this._type.decodeValue(b, vec._type));\n    }\n    return rets;\n  }\n\n  get name() {\n    return `vec ${this._type.name}`;\n  }\n\n  public display() {\n    return `vec ${this._type.display()}`;\n  }\n\n  public valueToString(x: T[]) {\n    const elements = x.map(e => this._type.valueToString(e));\n    return 'vec {' + elements.join('; ') + '}';\n  }\n}\n\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nexport class OptClass<T> extends ConstructType<[T] | []> {\n  constructor(protected _type: Type<T>) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitOpt(this, this._type, d);\n  }\n\n  public covariant(x: any): x is [T] | [] {\n    try {\n      if (Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0]))))\n        return true;\n    } catch (e: any) {\n      throw new Error(\n        `Invalid ${this.display()} argument: ${toReadableString(x)} \\n\\n-> ${e.message}`,\n      );\n    }\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: [T] | []) {\n    if (x.length === 0) {\n      return new Uint8Array([0]);\n    } else {\n      return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));\n    }\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(IDLTypeIds.Opt);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  public decodeValue(b: Pipe, t: Type): [T] | [] {\n    const opt = this.checkType(t);\n    if (!(opt instanceof OptClass)) {\n      throw new Error('Not an option type');\n    }\n    switch (safeReadUint8(b)) {\n      case 0:\n        return [];\n      case 1:\n        return [this._type.decodeValue(b, opt._type)];\n      default:\n        throw new Error('Not an option value');\n    }\n  }\n\n  get name() {\n    return `opt ${this._type.name}`;\n  }\n\n  public display() {\n    return `opt ${this._type.display()}`;\n  }\n\n  public valueToString(x: [T] | []) {\n    if (x.length === 0) {\n      return 'null';\n    } else {\n      return `opt ${this._type.valueToString(x[0])}`;\n    }\n  }\n}\n\n/**\n * Represents an IDL Record\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class RecordClass extends ConstructType<Record<string, any>> {\n  protected readonly _fields: Array<[string, Type]>;\n\n  constructor(fields: Record<string, Type> = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitRecord(this, this._fields, d);\n  }\n\n  public tryAsTuple(): Type[] | null {\n    const res: Type[] = [];\n    for (let i = 0; i < this._fields.length; i++) {\n      const [key, type] = this._fields[i];\n      if (key !== `_${i}_`) {\n        return null;\n      }\n      res.push(type);\n    }\n    return res;\n  }\n\n  public covariant(x: any): x is Record<string, any> {\n    if (\n      typeof x === 'object' &&\n      this._fields.every(([k, t]) => {\n        // eslint-disable-next-line\n        if (!x.hasOwnProperty(k)) {\n          throw new Error(`Record is missing key \"${k}\".`);\n        }\n        try {\n          return t.covariant(x[k]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nfield ${k} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: Record<string, any>) {\n    const values = this._fields.map(([key]) => x[key]);\n    const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Record);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) =>\n      concat(lebEncode(idlLabelToId(key)), value.encodeType(T)),\n    );\n\n    T.add(this, concat(opCode, len, concat(...fields)));\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    const record = this.checkType(t);\n    if (!(record instanceof RecordClass)) {\n      throw new Error('Not a record type');\n    }\n    const x: Record<string, any> = {};\n\n    let expectedRecordIdx = 0;\n    let actualRecordIdx = 0;\n    while (actualRecordIdx < record._fields.length) {\n      const [hash, type] = record._fields[actualRecordIdx];\n\n      if (expectedRecordIdx >= this._fields.length) {\n        // skip unexpected left over fields present on the wire\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n        continue;\n      }\n\n      const [expectKey, expectType] = this._fields[expectedRecordIdx];\n      const expectedId = idlLabelToId(this._fields[expectedRecordIdx][0]);\n      const actualId = idlLabelToId(hash);\n      if (expectedId === actualId) {\n        // the current field on the wire matches the expected field\n        x[expectKey] = expectType.decodeValue(b, type);\n        expectedRecordIdx++;\n        actualRecordIdx++;\n      } else if (actualId > expectedId) {\n        // The expected field does not exist on the wire\n        if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n          x[expectKey] = [];\n          expectedRecordIdx++;\n        } else {\n          throw new Error('Cannot find required field ' + expectKey);\n        }\n      } else {\n        // The field on the wire does not exist in the output type, so we can skip it\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n      }\n    }\n\n    // initialize left over expected optional fields\n    for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {\n      if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n        // TODO this assumes null value in opt is represented as []\n        x[expectKey] = [];\n      } else {\n        throw new Error('Cannot find required field ' + expectKey);\n      }\n    }\n    return x;\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public display() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: Record<string, any>) {\n    const values = this._fields.map(([key]) => x[key]);\n    const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nexport class TupleClass<T extends any[]> extends RecordClass {\n  protected readonly _components: Type[];\n\n  constructor(_components: Type[]) {\n    const x: Record<string, any> = {};\n    _components.forEach((e, i) => (x['_' + i + '_'] = e));\n    super(x);\n    this._components = _components;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitTuple(this, this._components, d);\n  }\n\n  public covariant(x: any): x is T {\n    // `>=` because tuples can be covariant when encoded.\n\n    if (\n      Array.isArray(x) &&\n      x.length >= this._fields.length &&\n      this._components.every((t, i) => {\n        try {\n          return t.covariant(x[i]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${i} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: any[]) {\n    const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  public decodeValue(b: Pipe, t: Type): T {\n    const tuple = this.checkType(t);\n    if (!(tuple instanceof TupleClass)) {\n      throw new Error('not a tuple type');\n    }\n    if (tuple._components.length < this._components.length) {\n      throw new Error('tuple mismatch');\n    }\n    const res = [];\n    for (const [i, wireType] of tuple._components.entries()) {\n      if (i >= this._components.length) {\n        // skip value\n        wireType.decodeValue(b, wireType);\n      } else {\n        res.push(this._components[i].decodeValue(b, wireType));\n      }\n    }\n    return res as T;\n  }\n\n  public display() {\n    const fields = this._components.map(value => value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public valueToString(values: any[]) {\n    const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n\n/**\n * Represents an IDL Variant\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class VariantClass extends ConstructType<Record<string, any>> {\n  private readonly _fields: Array<[string, Type]>;\n\n  constructor(fields: Record<string, Type> = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitVariant(this, this._fields, d);\n  }\n\n  public covariant(x: any): x is Record<string, any> {\n    if (\n      typeof x === 'object' &&\n      Object.entries(x).length === 1 &&\n      this._fields.every(([k, v]) => {\n        try {\n          // eslint-disable-next-line\n          return !x.hasOwnProperty(k) || v.covariant(x[k]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nvariant ${k} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: Record<string, any>) {\n    for (let i = 0; i < this._fields.length; i++) {\n      const [name, type] = this._fields[i];\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const idx = lebEncode(i);\n        const buf = type.encodeValue(x[name]);\n\n        return concat(idx, buf);\n      }\n    }\n    throw Error('Variant has no data: ' + x);\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._fields.forEach(([, type]) => {\n      type.buildTypeTable(typeTable);\n    });\n    const opCode = slebEncode(IDLTypeIds.Variant);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) =>\n      concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable)),\n    );\n    typeTable.add(this, concat(opCode, len, ...fields));\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    const variant = this.checkType(t);\n    if (!(variant instanceof VariantClass)) {\n      throw new Error('Not a variant type');\n    }\n    const idx = Number(lebDecode(b));\n    if (idx >= variant._fields.length) {\n      throw Error('Invalid variant index: ' + idx);\n    }\n    const [wireHash, wireType] = variant._fields[idx];\n    for (const [key, expectType] of this._fields) {\n      if (idlLabelToId(wireHash) === idlLabelToId(key)) {\n        const value = expectType.decodeValue(b, wireType);\n        return { [key]: value };\n      }\n    }\n    throw new Error('Cannot find field hash ' + wireHash);\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  public display() {\n    const fields = this._fields.map(\n      ([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`),\n    );\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: Record<string, any>) {\n    for (const [name, type] of this._fields) {\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const value = type.valueToString(x[name]);\n        if (value === 'null') {\n          return `variant {${name}}`;\n        } else {\n          return `variant {${name}=${value}}`;\n        }\n      }\n    }\n    throw new Error('Variant has no data: ' + x);\n  }\n}\n\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nexport class RecClass<T = any> extends ConstructType<T> {\n  private static _counter = 0;\n  private _id = RecClass._counter++;\n  private _type: ConstructType<T> | undefined = undefined;\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return v.visitRec(this, this._type, d);\n  }\n\n  public fill(t: ConstructType<T>) {\n    this._type = t;\n  }\n\n  public getType() {\n    return this._type;\n  }\n\n  public covariant(x: any): x is T {\n    if (this._type ? this._type.covariant(x) : false) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: T) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.encodeValue(x);\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    typeTable.add(this, new Uint8Array([]));\n    this._type.buildTypeTable(typeTable);\n    typeTable.merge(this, this._type.name);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.decodeValue(b, t);\n  }\n\n  get name() {\n    return `rec_${this._id}`;\n  }\n\n  public display() {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return `μ${this.name}.${this._type.name}`;\n  }\n\n  public valueToString(x: T) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.valueToString(x);\n  }\n}\n\nfunction decodePrincipalId(b: Pipe): PrincipalId {\n  const x = safeReadUint8(b);\n  if (x !== 1) {\n    throw new Error('Cannot decode principal');\n  }\n\n  const len = Number(lebDecode(b));\n  return PrincipalId.fromUint8Array(new Uint8Array(safeRead(b, len)));\n}\n\n/**\n * Represents an IDL principal reference\n */\nexport class PrincipalClass extends PrimitiveType<PrincipalId> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitPrincipal(this, d);\n  }\n\n  public covariant(x: any): x is PrincipalId {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: PrincipalId): ArrayBuffer {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Principal);\n  }\n\n  public decodeValue(b: Pipe, t: Type): PrincipalId {\n    this.checkType(t);\n    return decodePrincipalId(b);\n  }\n\n  get name() {\n    return 'principal';\n  }\n  public valueToString(x: PrincipalId) {\n    return `${this.name} \"${x.toText()}\"`;\n  }\n}\n\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nexport class FuncClass extends ConstructType<[PrincipalId, string]> {\n  public static argsToString(types: Type[], v: any[]) {\n    if (types.length !== v.length) {\n      throw new Error('arity mismatch');\n    }\n    return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n  }\n\n  constructor(public argTypes: Type[], public retTypes: Type[], public annotations: string[] = []) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFunc(this, d);\n  }\n  public covariant(x: any): x is [PrincipalId, string] {\n    if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string')\n      return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue([principal, methodName]: [PrincipalId, string]) {\n    const buf = principal.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    const canister = concat(new Uint8Array([1]), len, buf);\n\n    const method = new TextEncoder().encode(methodName);\n    const methodLen = lebEncode(method.byteLength);\n    return concat(new Uint8Array([1]), canister, methodLen, method);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this.argTypes.forEach(arg => arg.buildTypeTable(T));\n    this.retTypes.forEach(arg => arg.buildTypeTable(T));\n\n    const opCode = slebEncode(IDLTypeIds.Func);\n    const argLen = lebEncode(this.argTypes.length);\n    const args = concat(...this.argTypes.map(arg => arg.encodeType(T)));\n    const retLen = lebEncode(this.retTypes.length);\n    const rets = concat(...this.retTypes.map(arg => arg.encodeType(T)));\n    const annLen = lebEncode(this.annotations.length);\n    const anns = concat(...this.annotations.map(a => this.encodeAnnotation(a)));\n\n    T.add(this, concat(opCode, argLen, args, retLen, rets, annLen, anns));\n  }\n\n  public decodeValue(b: Pipe): [PrincipalId, string] {\n    const x = safeReadUint8(b);\n    if (x !== 1) {\n      throw new Error('Cannot decode function reference');\n    }\n    const canister = decodePrincipalId(b);\n\n    const mLen = Number(lebDecode(b));\n    const buf = safeRead(b, mLen);\n    const decoder = new TextDecoder('utf8', { fatal: true });\n    const method = decoder.decode(buf);\n\n    return [canister, method];\n  }\n\n  get name() {\n    const args = this.argTypes.map(arg => arg.name).join(', ');\n    const rets = this.retTypes.map(arg => arg.name).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) -> (${rets})${annon}`;\n  }\n\n  public valueToString([principal, str]: [PrincipalId, string]) {\n    return `func \"${principal.toText()}\".${str}`;\n  }\n\n  public display(): string {\n    const args = this.argTypes.map(arg => arg.display()).join(', ');\n    const rets = this.retTypes.map(arg => arg.display()).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) → (${rets})${annon}`;\n  }\n\n  private encodeAnnotation(ann: string): ArrayBuffer {\n    if (ann === 'query') {\n      return new Uint8Array([1]);\n    } else if (ann === 'oneway') {\n      return new Uint8Array([2]);\n    } else if (ann === 'composite_query') {\n      return new Uint8Array([3]);\n    } else {\n      throw new Error('Illegal function annotation');\n    }\n  }\n}\n\nexport class ServiceClass extends ConstructType<PrincipalId> {\n  public readonly _fields: Array<[string, FuncClass]>;\n  constructor(fields: Record<string, FuncClass>) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => {\n      if (a[0] < b[0]) {\n        return -1;\n      }\n      if (a[0] > b[0]) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitService(this, d);\n  }\n  public covariant(x: any): x is PrincipalId {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: PrincipalId) {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.length);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Service);\n    const len = lebEncode(this._fields.length);\n    const meths = this._fields.map(([label, func]) => {\n      const labelBuf = new TextEncoder().encode(label);\n      const labelLen = lebEncode(labelBuf.length);\n      return concat(labelLen, labelBuf, func.encodeType(T));\n    });\n\n    T.add(this, concat(opCode, len, ...meths));\n  }\n\n  public decodeValue(b: Pipe): PrincipalId {\n    return decodePrincipalId(b);\n  }\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `service {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: PrincipalId) {\n    return `service \"${x.toText()}\"`;\n  }\n}\n\n/**\n * Takes an unknown value and returns a string representation of it.\n * @param x - unknown value\n * @returns {string} string representation of the value\n */\nfunction toReadableString(x: unknown): string {\n  const str = JSON.stringify(x, (_key, value) =>\n    typeof value === 'bigint' ? `BigInt(${value})` : value,\n  );\n\n  return str && str.length > toReadableString_max\n    ? str.substring(0, toReadableString_max - 3) + '...'\n    : str;\n}\n\n/**\n * Encode a array of values\n * @param argTypes - array of Types\n * @param args - array of values\n * @returns {ArrayBuffer} serialised value\n */\nexport function encode(argTypes: Array<Type<any>>, args: any[]): ArrayBuffer {\n  if (args.length < argTypes.length) {\n    throw Error('Wrong number of message arguments');\n  }\n\n  const typeTable = new TypeTable();\n  argTypes.forEach(t => t.buildTypeTable(typeTable));\n\n  const magic = new TextEncoder().encode(magicNumber);\n  const table = typeTable.encode();\n  const len = lebEncode(args.length);\n  const typs = concat(...argTypes.map(t => t.encodeType(typeTable)));\n  const vals = concat(\n    ...zipWith(argTypes, args, (t, x) => {\n      try {\n        t.covariant(x);\n      } catch (e: any) {\n        const err = new Error(e.message + '\\n\\n');\n        throw err;\n      }\n\n      return t.encodeValue(x);\n    }),\n  );\n\n  return concat(magic, table, len, typs, vals);\n}\n\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nexport function decode(retTypes: Type[], bytes: ArrayBuffer): JsonValue[] {\n  const b = new Pipe(bytes);\n\n  if (bytes.byteLength < magicNumber.length) {\n    throw new Error('Message length smaller than magic number');\n  }\n  const magicBuffer = safeRead(b, magicNumber.length);\n  const magic = new TextDecoder().decode(magicBuffer);\n  if (magic !== magicNumber) {\n    throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n  }\n\n  function readTypeTable(pipe: Pipe): [Array<[IDLTypeIds, any]>, number[]] {\n    const typeTable: Array<[IDLTypeIds, any]> = [];\n    const len = Number(lebDecode(pipe));\n\n    for (let i = 0; i < len; i++) {\n      const ty = Number(slebDecode(pipe));\n      switch (ty) {\n        case IDLTypeIds.Opt:\n        case IDLTypeIds.Vector: {\n          const t = Number(slebDecode(pipe));\n          typeTable.push([ty, t]);\n          break;\n        }\n        case IDLTypeIds.Record:\n        case IDLTypeIds.Variant: {\n          const fields = [];\n          let objectLength = Number(lebDecode(pipe));\n          let prevHash;\n          while (objectLength--) {\n            const hash = Number(lebDecode(pipe));\n            if (hash >= Math.pow(2, 32)) {\n              throw new Error('field id out of 32-bit range');\n            }\n            if (typeof prevHash === 'number' && prevHash >= hash) {\n              throw new Error('field id collision or not sorted');\n            }\n            prevHash = hash;\n            const t = Number(slebDecode(pipe));\n            fields.push([hash, t]);\n          }\n          typeTable.push([ty, fields]);\n          break;\n        }\n        case IDLTypeIds.Func: {\n          const args = [];\n          let argLength = Number(lebDecode(pipe));\n          while (argLength--) {\n            args.push(Number(slebDecode(pipe)));\n          }\n          const returnValues = [];\n          let returnValuesLength = Number(lebDecode(pipe));\n          while (returnValuesLength--) {\n            returnValues.push(Number(slebDecode(pipe)));\n          }\n          const annotations = [];\n          let annotationLength = Number(lebDecode(pipe));\n          while (annotationLength--) {\n            const annotation = Number(lebDecode(pipe));\n            switch (annotation) {\n              case 1: {\n                annotations.push('query');\n                break;\n              }\n              case 2: {\n                annotations.push('oneway');\n                break;\n              }\n              case 3: {\n                annotations.push('composite_query');\n                break;\n              }\n              default:\n                throw new Error('unknown annotation');\n            }\n          }\n          typeTable.push([ty, [args, returnValues, annotations]]);\n          break;\n        }\n        case IDLTypeIds.Service: {\n          let servLength = Number(lebDecode(pipe));\n          const methods = [];\n          while (servLength--) {\n            const nameLength = Number(lebDecode(pipe));\n            const funcName = new TextDecoder().decode(safeRead(pipe, nameLength));\n            const funcType = slebDecode(pipe);\n            methods.push([funcName, funcType]);\n          }\n          typeTable.push([ty, methods]);\n          break;\n        }\n        default:\n          throw new Error('Illegal op_code: ' + ty);\n      }\n    }\n\n    const rawList: number[] = [];\n    const length = Number(lebDecode(pipe));\n    for (let i = 0; i < length; i++) {\n      rawList.push(Number(slebDecode(pipe)));\n    }\n    return [typeTable, rawList];\n  }\n  const [rawTable, rawTypes] = readTypeTable(b);\n  if (rawTypes.length < retTypes.length) {\n    throw new Error('Wrong number of return values');\n  }\n\n  const table: RecClass[] = rawTable.map(_ => Rec());\n  function getType(t: number): Type {\n    if (t < -24) {\n      throw new Error('future value not supported');\n    }\n    if (t < 0) {\n      switch (t) {\n        case -1:\n          return Null;\n        case -2:\n          return Bool;\n        case -3:\n          return Nat;\n        case -4:\n          return Int;\n        case -5:\n          return Nat8;\n        case -6:\n          return Nat16;\n        case -7:\n          return Nat32;\n        case -8:\n          return Nat64;\n        case -9:\n          return Int8;\n        case -10:\n          return Int16;\n        case -11:\n          return Int32;\n        case -12:\n          return Int64;\n        case -13:\n          return Float32;\n        case -14:\n          return Float64;\n        case -15:\n          return Text;\n        case -16:\n          return Reserved;\n        case -17:\n          return Empty;\n        case -24:\n          return Principal;\n        default:\n          throw new Error('Illegal op_code: ' + t);\n      }\n    }\n    if (t >= rawTable.length) {\n      throw new Error('type index out of range');\n    }\n    return table[t];\n  }\n  function buildType(entry: [IDLTypeIds, any]): Type {\n    switch (entry[0]) {\n      case IDLTypeIds.Vector: {\n        const ty = getType(entry[1]);\n        return Vec(ty);\n      }\n      case IDLTypeIds.Opt: {\n        const ty = getType(entry[1]);\n        return Opt(ty);\n      }\n      case IDLTypeIds.Record: {\n        const fields: Record<string, Type> = {};\n        for (const [hash, ty] of entry[1]) {\n          const name = `_${hash}_`;\n          fields[name] = getType(ty);\n        }\n        const record = Record(fields);\n        const tuple = record.tryAsTuple();\n        if (Array.isArray(tuple)) {\n          return Tuple(...tuple);\n        } else {\n          return record;\n        }\n      }\n      case IDLTypeIds.Variant: {\n        const fields: Record<string, Type> = {};\n        for (const [hash, ty] of entry[1]) {\n          const name = `_${hash}_`;\n          fields[name] = getType(ty);\n        }\n        return Variant(fields);\n      }\n      case IDLTypeIds.Func: {\n        const [args, returnValues, annotations] = entry[1];\n        return Func(\n          args.map((t: number) => getType(t)),\n          returnValues.map((t: number) => getType(t)),\n          annotations,\n        );\n      }\n      case IDLTypeIds.Service: {\n        const rec: Record<string, FuncClass> = {};\n        const methods = entry[1] as [[string, number]];\n        for (const [name, typeRef] of methods) {\n          let type: Type | undefined = getType(typeRef);\n\n          if (type instanceof RecClass) {\n            // unpack reference type\n            type = type.getType();\n          }\n          if (!(type instanceof FuncClass)) {\n            throw new Error('Illegal service definition: services can only contain functions');\n          }\n          rec[name] = type;\n        }\n        return Service(rec);\n      }\n      default:\n        throw new Error('Illegal op_code: ' + entry[0]);\n    }\n  }\n\n  rawTable.forEach((entry, i) => {\n    // Process function type first, so that we can construct the correct service type\n    if (entry[0] === IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n  rawTable.forEach((entry, i) => {\n    if (entry[0] !== IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n\n  const types = rawTypes.map(t => getType(t));\n  const output = retTypes.map((t, i) => {\n    return t.decodeValue(b, types[i]);\n  });\n\n  // skip unused values\n  for (let ind = retTypes.length; ind < types.length; ind++) {\n    types[ind].decodeValue(b, types[ind]);\n  }\n\n  if (b.byteLength > 0) {\n    throw new Error('decode: Left-over bytes');\n  }\n\n  return output;\n}\n\n/**\n * An Interface Factory, normally provided by a Candid code generation.\n */\nexport type InterfaceFactory = (idl: {\n  IDL: {\n    Empty: EmptyClass;\n    Reserved: ReservedClass;\n    Unknown: UnknownClass;\n    Bool: BoolClass;\n    Null: NullClass;\n    Text: TextClass;\n    Int: IntClass;\n    Nat: NatClass;\n\n    Float32: FloatClass;\n    Float64: FloatClass;\n\n    Int8: FixedIntClass;\n    Int16: FixedIntClass;\n    Int32: FixedIntClass;\n    Int64: FixedIntClass;\n\n    Nat8: FixedNatClass;\n    Nat16: FixedNatClass;\n    Nat32: FixedNatClass;\n    Nat64: FixedNatClass;\n\n    Principal: PrincipalClass;\n\n    Tuple: typeof Tuple;\n    Vec: typeof Vec;\n    Opt: typeof Opt;\n    Record: typeof Record;\n    Variant: typeof Variant;\n    Rec: typeof Rec;\n    Func: typeof Func;\n\n    Service(t: Record<string, FuncClass>): ServiceClass;\n  };\n}) => ServiceClass;\n\n// Export Types instances.\nexport const Empty = new EmptyClass();\nexport const Reserved = new ReservedClass();\n/**\n * Client-only type for deserializing unknown data. Not supported by Candid, and its use is discouraged.\n */\nexport const Unknown = new UnknownClass();\nexport const Bool = new BoolClass();\nexport const Null = new NullClass();\nexport const Text = new TextClass();\nexport const Int = new IntClass();\nexport const Nat = new NatClass();\n\nexport const Float32 = new FloatClass(32);\nexport const Float64 = new FloatClass(64);\n\nexport const Int8 = new FixedIntClass(8);\nexport const Int16 = new FixedIntClass(16);\nexport const Int32 = new FixedIntClass(32);\nexport const Int64 = new FixedIntClass(64);\n\nexport const Nat8 = new FixedNatClass(8);\nexport const Nat16 = new FixedNatClass(16);\nexport const Nat32 = new FixedNatClass(32);\nexport const Nat64 = new FixedNatClass(64);\n\nexport const Principal = new PrincipalClass();\n\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nexport function Tuple<T extends any[]>(...types: T): TupleClass<T> {\n  return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nexport function Vec<T>(t: Type<T>): VecClass<T> {\n  return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nexport function Opt<T>(t: Type<T>): OptClass<T> {\n  return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nexport function Record(t: Record<string, Type>): RecordClass {\n  return new RecordClass(t);\n}\n\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nexport function Variant(fields: Record<string, Type>): VariantClass {\n  return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nexport function Rec(): RecClass {\n  return new RecClass();\n}\n\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nexport function Func(args: Type[], ret: Type[], annotations: string[] = []): FuncClass {\n  return new FuncClass(args, ret, annotations);\n}\n\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nexport function Service(t: Record<string, FuncClass>): ServiceClass {\n  return new ServiceClass(t);\n}\n", "/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nexport function concat(...buffers: ArrayBuffer[]): ArrayBuffer {\n  const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n  let index = 0;\n  for (const b of buffers) {\n    result.set(new Uint8Array(b), index);\n    index += b.byteLength;\n  }\n  return result;\n}\n\n/**\n * Returns an hexadecimal representation of an array buffer.\n * @param bytes The array buffer.\n */\nexport function toHexString(bytes: ArrayBuffer): string {\n  return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\n/**\n * Return an array buffer from its hexadecimal representation.\n * @param hexString The hexadecimal string.\n */\nexport function fromHexString(hexString: string): ArrayBuffer {\n  return new Uint8Array((hexString.match(/.{1,2}/g) ?? []).map(byte => parseInt(byte, 16)));\n}\n\n/**\n * A class that abstracts a pipe-like ArrayBuffer.\n */\nexport class PipeArrayBuffer {\n  /**\n   * The reading view. It's a sliding window as we read and write, pointing to the buffer.\n   * @private\n   */\n  private _view: Uint8Array;\n\n  /**\n   * The actual buffer containing the bytes.\n   * @private\n   */\n  private _buffer: ArrayBuffer;\n\n  /**\n   * Creates a new instance of a pipe\n   * @param buffer an optional buffer to start with\n   * @param length an optional amount of bytes to use for the length.\n   */\n  constructor(buffer?: ArrayBuffer, length = buffer?.byteLength || 0) {\n    this._buffer = bufFromBufLike(buffer || new ArrayBuffer(0));\n    this._view = new Uint8Array(this._buffer, 0, length);\n  }\n\n  get buffer(): ArrayBuffer {\n    // Return a copy of the buffer.\n    return bufFromBufLike(this._view.slice());\n  }\n\n  get byteLength(): number {\n    return this._view.byteLength;\n  }\n\n  /**\n   * Read `num` number of bytes from the front of the pipe.\n   * @param num The number of bytes to read.\n   */\n  public read(num: number): ArrayBuffer {\n    const result = this._view.subarray(0, num);\n    this._view = this._view.subarray(num);\n    return result.slice().buffer;\n  }\n\n  public readUint8(): number | undefined {\n    const result = this._view[0];\n    this._view = this._view.subarray(1);\n    return result;\n  }\n\n  /**\n   * Write a buffer to the end of the pipe.\n   * @param buf The bytes to write.\n   */\n  public write(buf: ArrayBuffer): void {\n    const b = new Uint8Array(buf);\n    const offset = this._view.byteLength;\n    if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {\n      // Alloc grow the view to include the new bytes.\n      this.alloc(b.byteLength);\n    } else {\n      // Update the view to include the new bytes.\n      this._view = new Uint8Array(\n        this._buffer,\n        this._view.byteOffset,\n        this._view.byteLength + b.byteLength,\n      );\n    }\n\n    this._view.set(b, offset);\n  }\n\n  /**\n   * Whether or not there is more data to read from the buffer\n   */\n  public get end(): boolean {\n    return this._view.byteLength === 0;\n  }\n\n  /**\n   * Allocate a fixed amount of memory in the buffer. This does not affect the view.\n   * @param amount A number of bytes to add to the buffer.\n   */\n  public alloc(amount: number) {\n    // Add a little bit of exponential growth.\n    const b = new ArrayBuffer(((this._buffer.byteLength + amount) * 1.2) | 0);\n    const v = new Uint8Array(b, 0, this._view.byteLength + amount);\n    v.set(this._view);\n    this._buffer = b;\n    this._view = v;\n  }\n}\n\n/**\n * Returns a true ArrayBuffer from a Uint8Array, as Uint8Array.buffer is unsafe.\n * @param {Uint8Array} arr Uint8Array to convert\n * @returns ArrayBuffer\n */\nexport function uint8ToBuf(arr: Uint8Array): ArrayBuffer {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;\n}\n\n/**\n * Returns a true ArrayBuffer from an ArrayBufferLike object.\n * @param bufLike a buffer-like object\n * @returns ArrayBuffer\n */\nexport function bufFromBufLike(\n  bufLike:\n    | ArrayBuffer\n    | Uint8Array\n    | DataView\n    | ArrayBufferView\n    | ArrayBufferLike\n    | [number]\n    | number[]\n    | { buffer: ArrayBuffer },\n): ArrayBuffer {\n  if (bufLike instanceof Uint8Array) {\n    return uint8ToBuf(bufLike);\n  }\n  if (bufLike instanceof ArrayBuffer) {\n    return bufLike;\n  }\n  if (Array.isArray(bufLike)) {\n    return uint8ToBuf(new Uint8Array(bufLike));\n  }\n  if ('buffer' in bufLike) {\n    return bufFromBufLike(bufLike.buffer);\n  }\n  return uint8ToBuf(new Uint8Array(bufLike));\n}\n", "/**\n * Hashes a string to a number. Algorithm can be found here:\n * https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf\n * @param s - string to hash\n * @returns number representing hashed string\n */\nfunction idlHash(s: string): number {\n  const utf8encoder = new TextEncoder();\n  const array = utf8encoder.encode(s);\n\n  let h = 0;\n  for (const c of array) {\n    h = (h * 223 + c) % 2 ** 32;\n  }\n  return h;\n}\n\n/**\n *\n * @param label string\n * @returns number representing hashed label\n */\nexport function idlLabelToId(label: string): number {\n  if (/^_\\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {\n    const num = +label.slice(1, -1);\n    if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {\n      return num;\n    }\n  }\n  return idlHash(label);\n}\n", "/* eslint-disable no-constant-condition */\n// Note: this file uses buffer-pipe, which on Node only, uses the Node Buffer\n//       implementation, which isn't compatible with the NPM buffer package\n//       which we use everywhere else. This means that we have to transform\n//       one into the other, hence why every function that returns a Buffer\n//       actually return `new Buffer(pipe.buffer)`.\n// TODO: The best solution would be to have our own buffer type around\n//       Uint8Array which is standard.\nimport { PipeArrayBuffer as Pipe } from './buffer';\n\nfunction eob(): never {\n  throw new Error('unexpected end of buffer');\n}\n\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param num number\n * @returns Buffer\n */\nexport function safeRead(pipe: Pipe, num: number): ArrayBuffer {\n  if (pipe.byteLength < num) {\n    eob();\n  }\n  return pipe.read(num);\n}\n\n/**\n * @param pipe - PipeArrayBuffer simulating buffer-pipe api\n */\nexport function safeReadUint8(pipe: Pipe): number {\n  const byte = pipe.readUint8();\n  if (byte === undefined) {\n    eob();\n  }\n  return byte;\n}\n\n/**\n * Encode a positive number (or bigint) into a Buffer. The number will be floored to the\n * nearest integer.\n * @param value The number to encode.\n */\nexport function lebEncode(value: bigint | number): ArrayBuffer {\n  if (typeof value === 'number') {\n    value = BigInt(value);\n  }\n\n  if (value < BigInt(0)) {\n    throw new Error('Cannot leb encode negative values.');\n  }\n\n  const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;\n  const pipe = new Pipe(new ArrayBuffer(byteLength), 0);\n  while (true) {\n    const i = Number(value & BigInt(0x7f));\n    value /= BigInt(0x80);\n    if (value === BigInt(0)) {\n      pipe.write(new Uint8Array([i]));\n      break;\n    } else {\n      pipe.write(new Uint8Array([i | 0x80]));\n    }\n  }\n\n  return pipe.buffer;\n}\n\n/**\n * Decode a leb encoded buffer into a bigint. The number will always be positive (does not\n * support signed leb encoding).\n * @param pipe A Buffer containing the leb encoded bits.\n */\nexport function lebDecode(pipe: Pipe): bigint {\n  let weight = BigInt(1);\n  let value = BigInt(0);\n  let byte;\n\n  do {\n    byte = safeReadUint8(pipe);\n    value += BigInt(byte & 0x7f).valueOf() * weight;\n    weight *= BigInt(128);\n  } while (byte >= 0x80);\n\n  return value;\n}\n\n/**\n * Encode a number (or bigint) into a Buffer, with support for negative numbers. The number\n * will be floored to the nearest integer.\n * @param value The number to encode.\n */\nexport function slebEncode(value: bigint | number): ArrayBuffer {\n  if (typeof value === 'number') {\n    value = BigInt(value);\n  }\n\n  const isNeg = value < BigInt(0);\n  if (isNeg) {\n    value = -value - BigInt(1);\n  }\n  const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;\n  const pipe = new Pipe(new ArrayBuffer(byteLength), 0);\n  while (true) {\n    const i = getLowerBytes(value);\n    value /= BigInt(0x80);\n\n    // prettier-ignore\n    if (   ( isNeg && value === BigInt(0) && (i & 0x40) !== 0)\n          || (!isNeg && value === BigInt(0) && (i & 0x40) === 0)) {\n        pipe.write(new Uint8Array([i]));\n        break;\n      } else {\n        pipe.write(new Uint8Array([i | 0x80]));\n      }\n  }\n\n  function getLowerBytes(num: bigint): number {\n    const bytes = num % BigInt(0x80);\n    if (isNeg) {\n      // We swap the bits here again, and remove 1 to do two's complement.\n      return Number(BigInt(0x80) - bytes - BigInt(1));\n    } else {\n      return Number(bytes);\n    }\n  }\n  return pipe.buffer;\n}\n\n/**\n * Decode a leb encoded buffer into a bigint. The number is decoded with support for negative\n * signed-leb encoding.\n * @param pipe A Buffer containing the signed leb encoded bits.\n */\nexport function slebDecode(pipe: Pipe): bigint {\n  // Get the size of the buffer, then cut a buffer of that size.\n  const pipeView = new Uint8Array(pipe.buffer);\n  let len = 0;\n  for (; len < pipeView.byteLength; len++) {\n    if (pipeView[len] < 0x80) {\n      // If it's a positive number, we reuse lebDecode.\n      if ((pipeView[len] & 0x40) === 0) {\n        return lebDecode(pipe);\n      }\n      break;\n    }\n  }\n\n  const bytes = new Uint8Array(safeRead(pipe, len + 1));\n  let value = BigInt(0);\n  for (let i = bytes.byteLength - 1; i >= 0; i--) {\n    value = value * BigInt(0x80) + BigInt(0x80 - (bytes[i] & 0x7f) - 1);\n  }\n  return -value - BigInt(1);\n}\n\n/**\n *\n * @param value bigint or number\n * @param byteLength number\n * @returns Buffer\n */\nexport function writeUIntLE(value: bigint | number, byteLength: number): ArrayBuffer {\n  if (BigInt(value) < BigInt(0)) {\n    throw new Error('Cannot write negative values.');\n  }\n  return writeIntLE(value, byteLength);\n}\n\n/**\n *\n * @param value - bigint or number\n * @param byteLength - number\n * @returns ArrayBuffer\n */\nexport function writeIntLE(value: bigint | number, byteLength: number): ArrayBuffer {\n  value = BigInt(value);\n\n  const pipe = new Pipe(new ArrayBuffer(Math.min(1, byteLength)), 0);\n  let i = 0;\n  let mul = BigInt(256);\n  let sub = BigInt(0);\n  let byte = Number(value % mul);\n  pipe.write(new Uint8Array([byte]));\n  while (++i < byteLength) {\n    if (value < 0 && sub === BigInt(0) && byte !== 0) {\n      sub = BigInt(1);\n    }\n    byte = Number((value / mul - sub) % BigInt(256));\n    pipe.write(new Uint8Array([byte]));\n    mul *= BigInt(256);\n  }\n\n  return pipe.buffer;\n}\n\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nexport function readUIntLE(pipe: Pipe, byteLength: number): bigint {\n  let val = BigInt(safeReadUint8(pipe));\n  let mul = BigInt(1);\n  let i = 0;\n  while (++i < byteLength) {\n    mul *= BigInt(256);\n    const byte = BigInt(safeReadUint8(pipe));\n    val = val + mul * byte;\n  }\n  return val;\n}\n\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nexport function readIntLE(pipe: Pipe, byteLength: number): bigint {\n  let val = readUIntLE(pipe, byteLength);\n  const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));\n  if (val >= mul) {\n    val -= mul * BigInt(2);\n  }\n  return val;\n}\n", "/**\n * Equivalent to `Math.log2(n)` with support for `BigInt` values\n * @param n bigint or integer\n * @returns integer\n */\nexport function ilog2(n: bigint | number): number {\n  const nBig = BigInt(n);\n  if (n <= 0) {\n    throw new RangeError('Input must be positive');\n  }\n  return nBig.toString(2).length - 1;\n}\n\n/**\n * Equivalent to `2 ** n` with support for `BigInt` values\n * (necessary for browser preprocessors which replace the `**` operator with `Math.pow`)\n * @param n bigint or integer\n * @returns bigint\n */\nexport function iexp2(n: bigint | number): bigint {\n  const nBig = BigInt(n);\n  if (n < 0) {\n    throw new RangeError('Input must be non-negative');\n  }\n  return BigInt(1) << nBig;\n}\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport * as IDL from './idl';\n\nexport interface ParseConfig {\n  random?: boolean;\n}\n\nexport interface UIConfig {\n  input?: HTMLElement;\n  form?: InputForm;\n  parse(t: IDL.Type, config: ParseConfig, v: string): any;\n}\n\nexport interface FormConfig {\n  open?: HTMLElement;\n  event?: string;\n  labelMap?: Record<string, string>;\n  container?: HTMLElement;\n  render(t: IDL.Type): InputBox;\n}\n\nexport class InputBox {\n  public status: HTMLElement;\n  public label: string | null = null;\n  public value: any = undefined;\n\n  constructor(public idl: IDL.Type, public ui: UIConfig) {\n    const status = document.createElement('span');\n    status.className = 'status';\n    this.status = status;\n\n    if (ui.input) {\n      ui.input.addEventListener('blur', () => {\n        if ((ui.input as HTMLInputElement).value === '') {\n          return;\n        }\n        this.parse();\n      });\n      ui.input.addEventListener('input', () => {\n        status.style.display = 'none';\n        ui.input!.classList.remove('reject');\n      });\n    }\n  }\n  public isRejected(): boolean {\n    return this.value === undefined;\n  }\n\n  public parse(config: ParseConfig = {}): any {\n    if (this.ui.form) {\n      const value = this.ui.form.parse(config);\n      this.value = value;\n      return value;\n    }\n\n    if (this.ui.input) {\n      const input = this.ui.input as HTMLInputElement;\n      try {\n        const value = this.ui.parse(this.idl, config, input.value);\n        if (!this.idl.covariant(value)) {\n          throw new Error(`${input.value} is not of type ${this.idl.display()}`);\n        }\n        this.status.style.display = 'none';\n        this.value = value;\n        return value;\n      } catch (err) {\n        input.classList.add('reject');\n        this.status.style.display = 'block';\n        this.status.innerHTML = 'InputError: ' + (err as Error).message;\n        this.value = undefined;\n        return undefined;\n      }\n    }\n    return null;\n  }\n  public render(dom: HTMLElement): void {\n    const container = document.createElement('span');\n    if (this.label) {\n      const label = document.createElement('label');\n      label.innerText = this.label;\n      container.appendChild(label);\n    }\n    if (this.ui.input) {\n      container.appendChild(this.ui.input);\n      container.appendChild(this.status);\n    }\n\n    if (this.ui.form) {\n      this.ui.form.render(container);\n    }\n    dom.appendChild(container);\n  }\n}\n\nexport abstract class InputForm {\n  public form: InputBox[] = [];\n  constructor(public ui: FormConfig) {}\n\n  public abstract parse(config: ParseConfig): any;\n  public abstract generateForm(): any;\n  public renderForm(dom: HTMLElement): void {\n    if (this.ui.container) {\n      this.form.forEach(e => e.render(this.ui.container!));\n      dom.appendChild(this.ui.container);\n    } else {\n      this.form.forEach(e => e.render(dom));\n    }\n  }\n  public render(dom: HTMLElement): void {\n    if (this.ui.open && this.ui.event) {\n      dom.appendChild(this.ui.open);\n      const form = this;\n      // eslint-disable-next-line\n      form.ui.open!.addEventListener(form.ui.event!, () => {\n        // Remove old form\n        if (form.ui.container) {\n          form.ui.container.innerHTML = '';\n        } else {\n          const oldContainer = form.ui.open!.nextElementSibling;\n          if (oldContainer) {\n            oldContainer.parentNode!.removeChild(oldContainer);\n          }\n        }\n        // Render form\n        form.generateForm();\n        form.renderForm(dom);\n      });\n    } else {\n      this.generateForm();\n      this.renderForm(dom);\n    }\n  }\n}\n\nexport class RecordForm extends InputForm {\n  constructor(public fields: Array<[string, IDL.Type]>, public ui: FormConfig) {\n    super(ui);\n  }\n  public generateForm(): void {\n    this.form = this.fields.map(([key, type]) => {\n      const input = this.ui.render(type);\n      // eslint-disable-next-line\n      if (this.ui.labelMap && this.ui.labelMap.hasOwnProperty(key)) {\n        input.label = this.ui.labelMap[key] + ' ';\n      } else {\n        input.label = key + ' ';\n      }\n      return input;\n    });\n  }\n  public parse(config: ParseConfig): Record<string, any> | undefined {\n    const v: Record<string, any> = {};\n    this.fields.forEach(([key, _], i) => {\n      const value = this.form[i].parse(config);\n      v[key] = value;\n    });\n    if (this.form.some(input => input.isRejected())) {\n      return undefined;\n    }\n    return v;\n  }\n}\n\nexport class TupleForm extends InputForm {\n  constructor(public components: IDL.Type[], public ui: FormConfig) {\n    super(ui);\n  }\n  public generateForm(): void {\n    this.form = this.components.map(type => {\n      const input = this.ui.render(type);\n      return input;\n    });\n  }\n  public parse(config: ParseConfig): any[] | undefined {\n    const v: any[] = [];\n    this.components.forEach((_, i) => {\n      const value = this.form[i].parse(config);\n      v.push(value);\n    });\n    if (this.form.some(input => input.isRejected())) {\n      return undefined;\n    }\n    return v;\n  }\n}\n\nexport class VariantForm extends InputForm {\n  constructor(public fields: Array<[string, IDL.Type]>, public ui: FormConfig) {\n    super(ui);\n  }\n  public generateForm(): void {\n    const index = (this.ui.open as HTMLSelectElement).selectedIndex;\n    const [_, type] = this.fields[index];\n    const variant = this.ui.render(type);\n    this.form = [variant];\n  }\n  public parse(config: ParseConfig): Record<string, any> | undefined {\n    const select = this.ui.open as HTMLSelectElement;\n    const selected = select.options[select.selectedIndex].value;\n    const value = this.form[0].parse(config);\n    if (value === undefined) {\n      return undefined;\n    }\n    const v: Record<string, any> = {};\n    v[selected] = value;\n    return v;\n  }\n}\n\nexport class OptionForm extends InputForm {\n  constructor(public ty: IDL.Type, public ui: FormConfig) {\n    super(ui);\n  }\n  public generateForm(): void {\n    if ((this.ui.open as HTMLInputElement).checked) {\n      const opt = this.ui.render(this.ty);\n      this.form = [opt];\n    } else {\n      this.form = [];\n    }\n  }\n  public parse<T>(config: ParseConfig): [T] | [] | undefined {\n    if (this.form.length === 0) {\n      return [];\n    } else {\n      const value = this.form[0].parse(config);\n      if (value === undefined) {\n        return undefined;\n      }\n      return [value];\n    }\n  }\n}\n\nexport class VecForm extends InputForm {\n  constructor(public ty: IDL.Type, public ui: FormConfig) {\n    super(ui);\n  }\n  public generateForm(): void {\n    const len = +(this.ui.open as HTMLInputElement).value;\n    this.form = [];\n    for (let i = 0; i < len; i++) {\n      const t = this.ui.render(this.ty);\n      this.form.push(t);\n    }\n  }\n  public parse<T>(config: ParseConfig): T[] | undefined {\n    const value = this.form.map(input => {\n      return input.parse(config);\n    });\n    if (this.form.some(input => input.isRejected())) {\n      return undefined;\n    }\n    return value;\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport * as IDL from './idl';\nimport { Principal } from '@dfinity/principal';\nimport * as UI from './candid-core';\n\ntype InputBox = UI.InputBox;\n\nconst InputConfig: UI.UIConfig = { parse: parsePrimitive };\nconst FormConfig: UI.FormConfig = { render: renderInput };\n\nexport const inputBox = (t: IDL.Type, config: Partial<UI.UIConfig>) => {\n  return new UI.InputBox(t, { ...InputConfig, ...config });\n};\nexport const recordForm = (fields: Array<[string, IDL.Type]>, config: Partial<UI.FormConfig>) => {\n  return new UI.RecordForm(fields, { ...FormConfig, ...config });\n};\nexport const tupleForm = (components: IDL.Type[], config: Partial<UI.FormConfig>) => {\n  return new UI.TupleForm(components, { ...FormConfig, ...config });\n};\nexport const variantForm = (fields: Array<[string, IDL.Type]>, config: Partial<UI.FormConfig>) => {\n  return new UI.VariantForm(fields, { ...FormConfig, ...config });\n};\nexport const optForm = (ty: IDL.Type, config: Partial<UI.FormConfig>) => {\n  return new UI.OptionForm(ty, { ...FormConfig, ...config });\n};\nexport const vecForm = (ty: IDL.Type, config: Partial<UI.FormConfig>) => {\n  return new UI.VecForm(ty, { ...FormConfig, ...config });\n};\n\nexport class Render extends IDL.Visitor<null, InputBox> {\n  public visitType<T>(t: IDL.Type<T>, d: null): InputBox {\n    const input = document.createElement('input');\n    input.classList.add('argument');\n    input.placeholder = t.display();\n    return inputBox(t, { input });\n  }\n  public visitNull(t: IDL.NullClass, d: null): InputBox {\n    return inputBox(t, {});\n  }\n  public visitRecord(t: IDL.RecordClass, fields: Array<[string, IDL.Type]>, d: null): InputBox {\n    let config = {};\n    if (fields.length > 1) {\n      const container = document.createElement('div');\n      container.classList.add('popup-form');\n      config = { container };\n    }\n    const form = recordForm(fields, config);\n    return inputBox(t, { form });\n  }\n  public visitTuple<T extends any[]>(\n    t: IDL.TupleClass<T>,\n    components: IDL.Type[],\n    d: null,\n  ): InputBox {\n    let config = {};\n    if (components.length > 1) {\n      const container = document.createElement('div');\n      container.classList.add('popup-form');\n      config = { container };\n    }\n    const form = tupleForm(components, config);\n    return inputBox(t, { form });\n  }\n  public visitVariant(t: IDL.VariantClass, fields: Array<[string, IDL.Type]>, d: null): InputBox {\n    const select = document.createElement('select');\n    for (const [key, type] of fields) {\n      const option = new Option(key);\n      select.add(option);\n    }\n    select.selectedIndex = -1;\n    select.classList.add('open');\n    const config: Partial<UI.FormConfig> = { open: select, event: 'change' };\n    const form = variantForm(fields, config);\n    return inputBox(t, { form });\n  }\n  public visitOpt<T>(t: IDL.OptClass<T>, ty: IDL.Type<T>, d: null): InputBox {\n    const checkbox = document.createElement('input');\n    checkbox.type = 'checkbox';\n    checkbox.classList.add('open');\n    const form = optForm(ty, { open: checkbox, event: 'change' });\n    return inputBox(t, { form });\n  }\n  public visitVec<T>(t: IDL.VecClass<T>, ty: IDL.Type<T>, d: null): InputBox {\n    const len = document.createElement('input');\n    len.type = 'number';\n    len.min = '0';\n    len.max = '100';\n    len.style.width = '8rem';\n    len.placeholder = 'len';\n    len.classList.add('open');\n    const container = document.createElement('div');\n    container.classList.add('popup-form');\n    const form = vecForm(ty, { open: len, event: 'change', container });\n    return inputBox(t, { form });\n  }\n  public visitRec<T>(t: IDL.RecClass<T>, ty: IDL.ConstructType<T>, d: null): InputBox {\n    return renderInput(ty);\n  }\n}\n\nclass Parse extends IDL.Visitor<string, any> {\n  public visitNull(t: IDL.NullClass, v: string): null {\n    return null;\n  }\n  public visitBool(t: IDL.BoolClass, v: string): boolean {\n    if (v === 'true') {\n      return true;\n    }\n    if (v === 'false') {\n      return false;\n    }\n    throw new Error(`Cannot parse ${v} as boolean`);\n  }\n  public visitText(t: IDL.TextClass, v: string): string {\n    return v;\n  }\n  public visitFloat(t: IDL.FloatClass, v: string): number {\n    return parseFloat(v);\n  }\n  public visitFixedInt(t: IDL.FixedIntClass, v: string): number | bigint {\n    if (t._bits <= 32) {\n      return parseInt(v, 10);\n    } else {\n      return BigInt(v);\n    }\n  }\n  public visitFixedNat(t: IDL.FixedNatClass, v: string): number | bigint {\n    if (t._bits <= 32) {\n      return parseInt(v, 10);\n    } else {\n      return BigInt(v);\n    }\n  }\n  public visitNumber(t: IDL.PrimitiveType, v: string): bigint {\n    return BigInt(v);\n  }\n  public visitPrincipal(t: IDL.PrincipalClass, v: string): Principal {\n    return Principal.fromText(v);\n  }\n  public visitService(t: IDL.ServiceClass, v: string): Principal {\n    return Principal.fromText(v);\n  }\n  public visitFunc(t: IDL.FuncClass, v: string): [Principal, string] {\n    const x = v.split('.', 2);\n    return [Principal.fromText(x[0]), x[1]];\n  }\n}\n\nclass Random extends IDL.Visitor<string, any> {\n  public visitNull(t: IDL.NullClass, v: string): null {\n    return null;\n  }\n  public visitBool(t: IDL.BoolClass, v: string): boolean {\n    return Math.random() < 0.5;\n  }\n  public visitText(t: IDL.TextClass, v: string): string {\n    return Math.random().toString(36).substring(6);\n  }\n  public visitFloat(t: IDL.FloatClass, v: string): number {\n    return Math.random();\n  }\n  public visitInt(t: IDL.IntClass, v: string): bigint {\n    return BigInt(this.generateNumber(true));\n  }\n  public visitNat(t: IDL.NatClass, v: string): bigint {\n    return BigInt(this.generateNumber(false));\n  }\n  public visitFixedInt(t: IDL.FixedIntClass, v: string): number | bigint {\n    const x = this.generateNumber(true);\n    if (t._bits <= 32) {\n      return x;\n    } else {\n      return BigInt(v);\n    }\n  }\n  public visitFixedNat(t: IDL.FixedNatClass, v: string): number | bigint {\n    const x = this.generateNumber(false);\n    if (t._bits <= 32) {\n      return x;\n    } else {\n      return BigInt(v);\n    }\n  }\n  private generateNumber(signed: boolean): number {\n    const num = Math.floor(Math.random() * 100);\n    if (signed && Math.random() < 0.5) {\n      return -num;\n    } else {\n      return num;\n    }\n  }\n}\n\nfunction parsePrimitive(t: IDL.Type, config: UI.ParseConfig, d: string) {\n  if (config.random && d === '') {\n    return t.accept(new Random(), d);\n  } else {\n    return t.accept(new Parse(), d);\n  }\n}\n\n/**\n *\n * @param t an IDL type\n * @returns an input for that type\n */\nexport function renderInput(t: IDL.Type): InputBox {\n  return t.accept(new Render(), null);\n}\n\ninterface ValueConfig {\n  input: InputBox;\n  value: any;\n}\n\n/**\n *\n * @param t an IDL Type\n * @param input an InputBox\n * @param value any\n * @returns rendering that value to the provided input\n */\nexport function renderValue(t: IDL.Type, input: InputBox, value: any) {\n  return t.accept(new RenderValue(), { input, value });\n}\n\nclass RenderValue extends IDL.Visitor<ValueConfig, void> {\n  public visitType<T>(t: IDL.Type<T>, d: ValueConfig) {\n    (d.input.ui.input as HTMLInputElement).value = t.valueToString(d.value);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public visitNull(t: IDL.NullClass, d: ValueConfig) {}\n  public visitText(t: IDL.TextClass, d: ValueConfig) {\n    (d.input.ui.input as HTMLInputElement).value = d.value;\n  }\n  public visitRec<T>(t: IDL.RecClass<T>, ty: IDL.ConstructType<T>, d: ValueConfig) {\n    renderValue(ty, d.input, d.value);\n  }\n  public visitOpt<T>(t: IDL.OptClass<T>, ty: IDL.Type<T>, d: ValueConfig) {\n    if (d.value.length === 0) {\n      return;\n    } else {\n      const form = d.input.ui.form!;\n      const open = form.ui.open as HTMLInputElement;\n      open.checked = true;\n      open.dispatchEvent(new Event(form.ui.event!));\n      renderValue(ty, form.form[0], d.value[0]);\n    }\n  }\n  public visitRecord(t: IDL.RecordClass, fields: Array<[string, IDL.Type]>, d: ValueConfig) {\n    const form = d.input.ui.form!;\n    fields.forEach(([key, type], i) => {\n      renderValue(type, form.form[i], d.value[key]);\n    });\n  }\n  public visitTuple<T extends any[]>(t: IDL.TupleClass<T>, components: IDL.Type[], d: ValueConfig) {\n    const form = d.input.ui.form!;\n    components.forEach((type, i) => {\n      renderValue(type, form.form[i], d.value[i]);\n    });\n  }\n  public visitVariant(t: IDL.VariantClass, fields: Array<[string, IDL.Type]>, d: ValueConfig) {\n    const form = d.input.ui.form!;\n    const selected = Object.entries(d.value)[0];\n    fields.forEach(([key, type], i) => {\n      if (key === selected[0]) {\n        const open = form.ui.open as HTMLSelectElement;\n        open.selectedIndex = i;\n        open.dispatchEvent(new Event(form.ui.event!));\n        renderValue(type, form.form[0], selected[1]);\n      }\n    });\n  }\n  public visitVec<T>(t: IDL.VecClass<T>, ty: IDL.Type<T>, d: ValueConfig) {\n    const form = d.input.ui.form!;\n    const len = d.value.length;\n    const open = form.ui.open as HTMLInputElement;\n    open.value = len;\n    open.dispatchEvent(new Event(form.ui.event!));\n    d.value.forEach((v: T, i: number) => {\n      renderValue(ty, form.form[i], v);\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["Principal", "Principal"]
}
